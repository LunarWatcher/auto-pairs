*AutoPairs.txt* *autopairs* *AutoPairs*

Insert or delete brackets, parens, and quotes in pair (a fork by LunarWatcher)

Author:  jiangmiao
Fork: LunarWatcher (Olivia)
License: MIT
URL: https://github.com/jiangmiao/auto-pairs
Fork URL: https://github.com/LunarWatcher/auto-pairs (bugs, feature requests,
                                                      and pull requests go
                                                      here)
Changelog: https://github.com/LunarWatcher/auto-pairs/blob/master/CHANGELOG.md

==============================================================================
CONTENTS                                                    *autopairs-contents*

    1.  Installation ............................ |autopairs-installation|
    2.  Features .................................... |autopairs-features|
         2.1. Multibyte pairs ...................... |autopairs-multibyte|
    3.  Fly Mode ..................................... |autopairs-flymode|
    4.  Shortcuts .................................. |autopairs-shortcuts|
         4.1. Shortcut remapping .......... |autopairs-shortcut-remapping|
    5.  Options ...................................... |autopairs-options|
    6.  Troubleshooting ...................... |autopairs-troubleshooting|
         6.1. Conflicting keybinds ................. |autopairs-conflicts|
    7.  Diagnosing indentation ............... |autopairs-diagnose-indent|
    8.  Functions (API) ............................ |autopairs-functions|
    9.  Credits/contributors ......................... |autopairs-credits|

==============================================================================
1. Installation                                         *autopairs-installation*

With vim-plug: >

    Plug 'LunarWatcher/auto-pairs'
<
Preferred/recommended: >
    Plug 'LunarWatcher/auto-pairs', {'tag': '*'}
<

Other installation methods are of course supported, but aren't documented
because the author of this help document couldn't be bothered to add all of
them. Most of them should work with a similar syntax anyway, and there's no
special install instructions aside just installing it. No compiling, no
external dependencies, just pure Vimscript.

==============================================================================
2. Features                                                 *autopairs-features*

Insert in pair: >

        input: [
        output: [|]

Delete in pair: >

        input: foo[<BS>]
        output: foo

Insert new indented line after Return: >

        input: {|} (press <CR> at |)
        output: {
            |
        }

Insert spaces before closing characters, only for [], (), {}: >

        input: {|} (press <SPACE> at |)
        output: { | }

        input: {|} (press <SPACE>foo} at |)
        output: { foo }|

        input: '|' (press <SPACE> at |)
        output: ' |'

Skip ' when inside a word: >

        input: foo| (press ' at |)
        output: foo'

Skip closed bracket: >

        input: []
        output: []

Ignore auto pair when previous character is '\': >

        input: "\'
        output: "\'"

Fast Wrap: >

        input: |'hello' (press (<M-e> at |)
        output: ('hello')

    Wrap string, only support c style string.
        input: |'h\\el\'lo' (press (<M-e> at |)
        output ('h\\ello\'')

        input: |[foo, bar()] (press (<M-e> at |)
        output: ([foo, bar()])

Quick jump to closed pair: >

        input:
        {
            something;|
        }

        (press } at |)

        output:
        {

        }|

Support ```, ''' and """: >

        input:
            '''

        output:
            '''|'''

Delete Repeated Pairs in one time: >

        input: """|""" (press <BS> at |)
        output: |

        input: {{|}} (press <BS> at |)
        output: |

        input: [[[[[[|]]]]]] (press <BS> at |)
        output: |

Fly Mode (|autopairs-flymode|): >

        input: if(a[3)
        output: if(a[3])| (In Fly Mode)
        output: if(a[3)]) (Without Fly Mode)

        input:
        {
            hello();|
            world();
        }

        (press } at |)

        output:
        {
            hello();
            world();
        }|

        (then press <M-b> at | to do backinsert)
        output:
        {
            hello();}|
            world();
        }

        See |Fly Mode| section for details

Only inserting when the next character is a space (*autopairs-tbd*)
------------------------------------------------------------------------------
2.1. Multibyte pairs                                       *autopairs-multibyte*

Support for multibyte pairs was added in an earlier version of the plugin
(prior to the forking). They're exactly what you'd think: they're pairs that
contain multiple bytes. One example of this is `'"""': '"""'`, and
`'{%', '%}'.`These act in a compose-like manner, so you can both have {} and
{%%} pairs without breaking one or the other.

These pairs are added in the exact same way as other pairs.

This can theoretically be used for HTML tags as well, but the number of rules
for that would end up being rather ridiculous. There's currently a plan to add
more flexible rules, including stuff applicable to HTML tags and if-else in
some languages, but it's not implemented at this time.

==============================================================================
3. Fly Mode                                                  *autopairs-flymode*

Fly Mode will always force closed-pair jumping instead of inserting. Only for
")", "}", "]". If jumps in mistake, you can use |g:AutoPairsBackInsert| (default
Key: <M-b>) to jump back and insert closed pair.

The most situation maybe you want to insert single closed pair in the string,
eg: >

    ")"

Fly Mode is DISABLED by default. To enable Fly Mode add following to your
'.vimrc': >

    let g:AutoPairsFlyMode = 1

Default Options: >

    let g:AutoPairsFlyMode = 0
    let g:AutoPairsShortcutBackInsert = '<M-b>'

Note: Flymode is currently considered buggy and unreliable. It should be avoided
unless you enjoy spending time on flymode doing weird shit while you're
typing.

==============================================================================
4. Shortcuts                                               *autopairs-shortcuts*

System Shortcuts:
    <CR> : Insert new indented line after return if cursor in blank brackets
           or quotes.
    <BS> : Delete brackets in pair
    <M-p>: Toggle Autopairs (|g:AutoPairsShortcutToggle|)
    <M-e>: Fast Wrap (|g:AutoPairsShortcutFastWrap|)
    <M-n>: Jump to next closed pair (|g:AutoPairsShortcutJump|)
    <M-b>: BackInsert (|g:AutoPairsShortcutBackInsert|)


    To rebind keys <M-p>, <M-e> or <M-n> or in case of conflicts with
    another keys:

        let g:AutoPairsShortcutToggle = '<another key>'

    If the key is empty string '', then the shortcut will be disabled.

------------------------------------------------------------------------------
4.1. Remapping shortcuts                          *autopairs-shortcut-remapping*

At this time, most keybinds are remappable by using various options (see
|autopairs-options|). The goal is for all of them to be possible to remap.

Additionally, there's currently one keybind that lets you remap `<cr>`, to
prevent <cr> conflicts. It requires you to remap it explicitly, though.

==============================================================================
5. Options                                                   *autopairs-options*

These options exist in a global variant (`g:variableName`), and a local
variant (`b:variableName`), where `variableName` refers to some defined
variable. The documentation should contain a notice when a buffer variable
exists, but as it's still being added, it may be incomplete. See
autopairs#AutoPairsInit()'s source if in doubt.

------------------------------------------------------------------------------
                                                                   *g:AutoPairs*
                                                                   *b:AutoPairs*
|g:AutoPairs|                                                             dict
This variable also exists in a buffer variant.~

Default: >
    {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '```':'```', '"""':'"""', "'''":"'''", "`":"`"}

Specifies which symbols should be automatically paired.

To append new pairs without overwriting defaults, add values in your
`.vimrc`.: >
    let g:AutoPairs = autopairs#AutoPairsDefine({'<': '>'})
<
Older versions of this plugin didn't use autoload, which made the above
invalid, and required `autocmd VimEnter *` to be used as well. This is no
longer the case.

The example above will enable matching of `<` with `>`. You can also use: >
    let g:AutoPairs = { '(': ')', ...}
<

... where the `...` represents additional mappings, but note that this overrides
all the defaults. If you only do the first mapping in the above example, for
an instance, the ONLY key bracket/quote/other auto-pairs knows of is ().

Similarly, you can use a the FileType event to
`let b:AutoPairs = autopairs#AutoPairsDefine({'<': '>'})`, and only have <> for some
filetypes. Again, dropping AutoPairsDefine and just using the object will
result in _only_ <> being matched. Newer versions of the plugin additionally
ship with |g:AutoPairsLanguagePairs|. Please read the docs carefully before
using it, though; there's currently no way to sanely set it in a way that
preserves defaults without forcing autopairs to load in an awkward way.

Not using |autopairs#AutoPairsDefine()| will result in the standards being lost. If you
don't want to use the standards, go ahead and omit this function.
Additionally, if you want to add new types after loading the file
(specifically, when BufEnter has been triggered for auto-pairs), you need to
use |autopairs#AutoPairsMap()| to register the new keybind. Using this function isn't
necessary for standard |FileType| autocmds, however.

Previous versions of this document supported a type of assignment that doesn't
work due to plugin sourcing systems.

`g:AutoPair` additionally supports several types of multibyte pairs. If you're
frequently coding in an HTML template language, `"{%": "%}"` can be added to
the buffer variant of this variable (used in combination with an
`autocmd FileType`). The current behavior:
>
    Input: {|
    Output: {|}
    Input: %
    Output: {%|%}
<

There's built-in support for """ and ''', and more can be added if necessary.
There shouldn't be a limit the length (though, for obvious reasons, things
might go wrong if you decide to input an obnoxiously long mapping), so you
should be able to map all pairs used by your favorite language or framework.

You can set |b:AutoPairs| before |BufEnter|: >

    au Filetype FILETYPE let b:AutoPairs = {"(": ")"}

This sets |AutoPairs| to only match for parenthesis for 'FILETYPE'. See also
|g:AutoPairsLanguagePairs|.
                                                     |autopairs-weird-behavior|


Open is used in a regex search, and because auto-pairs applies stuff directly,
there's a minor input escape issue. Most people aren't going to experience it,
but if you i.e. wanna add `'\left(': '\right)'`, there is actually a "right
way" to add it. `\left` may cause `\l` to be interpreted as a group; |\l|
to be specific.

Consequentially, the pair has to be declared as `'\\left(': '\right)'` . The
close pair is also used as a regex in some places, but shouldn't cause any
problems. Additional escaping will be added soon to mitigate problems, but
it's fairly niche. TL;DR: if you use backslash in an open pair, you _need_ to
escape it with `\\` for it to work properly

This is a bit of a double-sided blade, though; forcing escape of the close
pair in certain places means regex cannot be used. Regex groups for replace
cannot be used either way, so there should be relatively few reasons to have
regex in the closing pair.

Note that all the pairs are run through a \V, so some characters should be
entirely escaped. Direct use consequentially means you can `\v` and get
creative with regexes for pairs.

------------------------------------------------------------------------------
                                                *g:AutoPairsCompleteOnlyOnSpace*
|g:AutoPairsCompleteOnlyOnSpace|                                          number
This variable also exists in a buffer variant.~

Default: 0

Defines whether or not to require a space or EOL to complete. If this is 1 and
you try: `{|word`, you'll get `{|word`, rather than `{|}word` if this is 0.

3.0.0-alpha5:~
    renamed from *g:AutoPairsCompleteOnSpace* to |g:AutoPairsCompleteOnlyOnSpace|

------------------------------------------------------------------------------
                                                     *g:AutoPairsShortcutToggle*
|g:AutoPairsShortcutToggle|                                               string

Default: <M-p>

The shortcut to toggle autopairs.

------------------------------------------------------------------------------
                                                   *g:AutoPairsShortcutFastWrap*
|g:AutoPairsShortcutFastWrap|                                             string

Default: <M-e>

Fast wrap the word. All pairs will be considered as a block (including <>).

        (|)'hello' after fast wrap at |, the word will be ('hello')
        (|)<hello> after fast wrap at |, the word will be (<hello>)


------------------------------------------------------------------------------
                                                       *g:AutoPairsShortcutJump*
|g:AutoPairsShortcutJump|                                                 string

Default: <M-n>

Jump to the next closed pair.

------------------------------------------------------------------------------
                                                 *g:AutoPairsShortcutBackInsert*
|g:AutoPairsShortcutBackInsert|                                           string

Default: <M-b>

Work with |autopairs-flymode|, insert the key at the Fly Mode jumped position.


------------------------------------------------------------------------------
                                                              *g:AutoPairsMapBS*
|g:AutoPairsMapBS|                                                           int

Default: 0

Map <BS> to delete brackets and quotes in pair, executes:

    inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>

------------------------------------------------------------------------------
                                                              *g:AutoPairsMapCR*
|g:AutoPairsMapCR|                                                           int

Default: 1

Map <CR> to insert a new indented line if cursor in (|), {|} [|], '|', "|".
Executes: >
    inoremap <expr> <buffer> <silent> <CR> AutoPairsReturn()
<
------------------------------------------------------------------------------
                                                         *g:AutoPairsCenterLine*
|g:AutoPairsCenterLine|                                                      int

Default: 1

When |g:AutoPairsMapCR| is on, center current line after return if the line
is at the bottom 1/3 of the window.

------------------------------------------------------------------------------
                                                           *g:AutoPairsMapSpace*
|g:AutoPairsMapSpace|                                                        int

Default: 1

Map <space> to insert a space after the opening character and before the
closing one.

Executes: >
    Vim 7.703 and up:
          inoremap <buffer> <silent> <SPACE> <C-]><C-R>=AutoPairsSpace()<CR>
    Else: inoremap <buffer> <silent> <SPACE> <C-R>=AutoPairsSpace()<CR>
<

------------------------------------------------------------------------------
                                                            *g:AutoPairsFlyMode*
|g:AutoPairsFlyMode|                                                         int

Default: 0
This variable also exists in a buffer variant.~

Set it to 1 to enable |autopairs-flymode|.

------------------------------------------------------------------------------
                                                     *g:AutoPairsMultilineClose*
|g:AutoPairsMultilineClose|                                                  int

Default: 0

Krasjet's fork defined this to be 0 due to personal preference.

When you press the key for the closing pair (e.g. `)`) it jumps past it.
If set to 1, then it'll jump to the next line, if there is only 'whitespace'.
If set to 0, then it'll only jump to a closing pair on the same line.

------------------------------------------------------------------------------
                                                 *g:AutoPairsDirectoryBlacklist*
|g:AutoPairsDirectoryBlacklist|                                        path list

Default: []

Defines a set of directories (checked against |getcwd()|) in which the plugin
is disabled. This is pretty much a utility around `let b:autopairs_enabled = 0`,
which means the plugin is toggled in the buffer.

It's disabled by default as this means it's possible to load it after the
fact, where as a complete block wouldn't allow for manually enabling the
plugin, if desired.

See also |g:AutoPairsShortcutToggle|

------------------------------------------------------------------------------
                                                           *b:autopairs_enabled*

Type: int
Default: 1

This is a buffer variable that defines whether or not autopairs is enabled.
You can use this variable to get more fine-grained control over when the
plugin is enabled as well, if the built-in options aren't satisfactory.

------------------------------------------------------------------------------
                                                           *g:AutoPairsInitHook*

Type: |function()| (generally, a funcref)
Default: 0 (intended as null)

This variable lets you do stuff before the initialization of auto-pairs. The
indent behind this variable is to reduce the need for |autopairs-functions| as
much as possible, as the use of these may cause more problems than good. Their
use also requires understanding how they work and when they're supposed to be
called, which may be a bit much to ask for if the intent is a bit of
customization.

It's not required; its primary purpose is for cases where you cannot get away
with using an autocmd, or the execution order of autocmds prevents the
functionality you intend. The function, if present, is triggered as a part of
AutoPairsTryInit, which essentially contains the start of initialization. The
function is, to be specific, called before any other logic to enable variable
initialization.

Example use~
>
    fun! s:myFunc()
        echo "This is my autopairs hook"
    endfun
    let g:AutoPairsInitHook = function('s:myFunc')
<

Note~

While the example uses function(), and the type listed is function(), its
underlaying |type()| is a funcref. There's many ways to Rome on this one, so
you don't _have_ to use a |function()| to get the funcref.

------------------------------------------------------------------------------
                                                             *g:AutoPairsNoJump*
|g:AutoPairsNoJump|                                                          int
Default: 0
This variable also exists in a buffer variant.~

Sets whether or not jump behavior should be invoked. If this variable is set
to 1, no automatic jumps will be performed. Basically:

value = 0:
>
    Before: (|)     (input: ')', without the quotes)
    After : ()|
<
value = 1:
>
    Before: (|)     (input: ')', without the quotes)
    After : ()|)
<

------------------------------------------------------------------------------
                                              *g:AutoPairsSearchCloseAfterSpace*
|g:AutoPairsSearchCloseAfterSpace|                                           int
Default: 1
This variable also exists in a buffer variant.~

Sets whether or not to search for close brackets after a space. This is
default behavior in jiangmiao/auto-pairs, and disabled in krasjet/auto.pairs.
Neither of the two have an option to toggle this, however.

value = 0:
>
    Before: [ | ]   (input: ']', without the quotes)
    After : [ ]| ]
<

value = 1:
>
    Before: [ | ]   (input: ']', without the quotes)
    After : [ ]|
<

------------------------------------------------------------------------------
                                                    *g:AutoPairsSingleQuoteMode*
|g:AutoPairsSingleQuoteMode|                                                 int

Default: 2
Default for upstream: 0
Allowed values: [0, 1, 2]
This variable also exists in a buffer variant.~

Defines how to handle single-quotes. This is new in the fork and alters
existing behavior. "Default for upstream" is meant to refer to what upstream
does, although it doesn't have this option. If you prefer the standard
behavior of jiangmiao/auto-pairs, `let g.AutoPairsSingleQuoteMode = 0`

If 0: "Standard" behavior, never expand <letter>' to <letter>''. No
      exceptions.
If 1: Allow one character in front of the quote to expand. Will trigger on
      I'm.
If 2: Allow specific characters in front of the quote to expand. Should not
      yield false positives. Looks in |g:AutoPairsSingleQuoteExpandFor|.
      Will not trigger on cases like I'm unless I (case sensitive) is present
      in |g:AutoPairsSingleQuoteExpandFor|. See the second note.

You can also use an
`autocmd FileType <text files> let b:AutoPairsSingleQuoteMode = 0` if you
wanna use some other behavior on code files, but be strict in text files.

Note that without parsing comments on a per-language basis (AKA literally
hell, because no one seems to agree to just settle on one comment style),
there's not gonna be a lot of solutions that don't yield some false positives.
mode 2 is the one guaranteed to yield no false positives, but does trigger a
whole bunch of true negatives. Mixing 0 and 2 depending on the filetype is
probably your best bet.

Note: 2, from an English perspective, yields very few or no false positives.
f', g', and r' either don't exist as prefix to words, or are so rare only a
few niche words count. Might not hold if you're writing a D&D story, but
that's why option 0 exists.

You're free to chose whatever mode you want in whatever files you want in
whatever combination you want based on what works for you.

------------------------------------------------------------------------------
                                               *g:AutoPairsSingleQuoteExpandFor*
|g:AutoPairsSingleQuoteExpandFor|         (case-sensitive) regex character group
This variable also exists in a buffer variant.~

Default: 'fbr'
Type clarification: the string is parsed in as a part of a regex character
group. It's only meant to contain pure characters, though it can obviously be
used to inject stuff into the regex that isn't meant to be there.

Used with |g:AutoPairsSingleQuoteMode| = 2

------------------------------------------------------------------------------
                                                      *g:AutoPairsLanguagePairs*
|g:AutoPairsLanguagePairs|                                                   map

Default: >
    {
        \ "erlang": {'<<': '>>'},
        \ "tex": {'``': "''" },
        \ "html": {'<': '>'},
        \ 'vim': {'\v(^\s*\zs"\ze|".*"\s*\zs"\ze$|^(\s*[a-zA-Z]+\s*([a-zA-Z]*\s*\=\s*)?)@!(\s*\zs"\ze(\\\"|[^"])*$))': ''},
        \ 'rust': {'\w\zs<': '>', '&\zs''': ''},
        \ 'php': {'<?': '?>//k]', '<?php': '?>//k]'}
        \ }
<

Contains an map of maps containing language-specific expansions. This is
essentially the fancy way of using autocmds.

Language pairs come with a bunch of predefined stuff. This is largely for
dealing with custom pairs or exceptions to pairs (such as in the case of Vim,
where "" both is and isn't quotes. Vimscript is weird, okay?). The pairs have
been |\V|'d prior to usage, which means it's perfectly possible to use |\v| in
the open bracket to get fancy with the script. Note: make sure
that the last character of your regex is the same as the last character typed
in your construct. If you end your regex with a *, but the last character
typed is ), it won't necessarily complete because * (the last character) is
the key that gets mapped. It could still be mapped purely coincidentally, of
course, but you'd still end up with a key mapped uselessly.

Note, however, that due to the way the plugin is built, the replace group does
NOT support regex capture groups. This is also part of why HTML/XML tag
completion isn't on the list of things to do: while it could easily be done
with `'<[a-zA-Z0-9_-]>': '</\1>'`, not having the ability to use \1 easily for
insertion (caused by the design of the plugin, and it's not easy to fix),
means attempts to deal with HTML-like tags using regex simply aren't feasible.

------------------------------------------------------------------------------
                                                      *g:AutoPairsAutoLineBreak*
|g:AutoPairsAutoLineBreak|                                                  list

Default: []
This variable also exists in a buffer variant.~

Contains a list of opening brackets  that result in an instant linebreak. It's
empty by default as this is one of the more intrusive options -- make sure you
want this when you set it.

Example, assuming '{' is in the list: >
    Input : {|
    Output: {
                |
            }
<

Note that the exact cursor and bracket positions may vary. See
|autopairs-indent-problems| and |indent|.
------------------------------------------------------------------------------
                                             *g:AutoPairsCarefulStringExpansion*
|g:AutoPairsCarefulStringExpansion|                                          int

Default: 0
This variable also exists in a buffer variant.~

Defines whether or not to do "careful" string expansion on <CR>. Careful in
this case essentially means, count whether or not the amount of quotes in the
previous line is divisible by 2. If it is, assume whatever we're doing is the
start of a new string and therefore don't do the normal <CR> string expansion.
Otherwise, run it.

See: https://github.com/jiangmiao/auto-pairs/issues/277

This is the dumbest variant of string checks I can think of. It's not in any
way safe for use with various weird edge cases in your favorite language:tm:,
and will probably misbehave. The best option I could come up with (that also
failed because I couldn't find a good way to implement it) is checking for the
existence of syn string groups. Unfortunately, by the time AutoPairsReturn is
executed, the linebreak has already taken place. As a result, I can't actually
test in the former spot. Moreover, if I measure the previous spot and it's a
quote, the string syngroup is present.

This variable will be replaced in the future if I'm able to find a way to use
syngroups instead of this idiotic check.

This check being dumb consequentially means it can lead to other unwanted
behavior, or just give incorrect results. Therefore, it's disabled by default.
I don't want to push something that's likely to cause problems and requires
config with some languages into the general public.

------------------------------------------------------------------------------
                                                             *g:AutoPairsQuotes*
|g:AutoPairsQuotes|                                                          int

Default: ["'", '"']
This variable also exists in a buffer variant.~

Controls what openers trigger |g:AutoPairsCarefulStringExpansion|. Note that
for implementation reasons, this only works when the openers and closers are
the same.

------------------------------------------------------------------------------
                                               *g:AutoPairsOpenBalanceBlacklist*
|g:AutoPairsOpenBalanceBlacklist|                                          array
This variable also exists in a buffer variant.~

Default: []

Blacklist for checking for balance before inserting.

3.0.0-beta3:~
    * Made the default [], because defaulting to quotes triggered weird
      behavior, and I can't remember the rationale for adding them in the
      first place

------------------------------------------------------------------------------
                                                  *g:AutoPairsMultilineFastWrap*
|g:AutoPairsMultilineFastWrap|                                               int

Default: 0

Whether or not to enable multiline fast wrap.

The only real differenec is that it enables $ in the fallback condition.
When $ isn't present, pressing the fast wrap key at a position that doesn't
match \w for the next character results in nothing changing. If $ is present,
it moves to the next line if said line exists.

Note that this does NOT affect multilines triggered by brackets. It'll still
fast-wrap across lines if a pair is detected independently of this setting.

Disabled by default because this introduced breaking behavior in comparison.
------------------------------------------------------------------------------
                                                    *g:AutoPairsBackwardsCompat*
|g:AutoPairsBackwardsCompat|                                                 int

Default: 1 if mg979/vim-visual-multi is detected, 0 otherwise

Whether or not to expose the backwards compat API. This MUST be set before
plugin/ is sourced. It cannot be toggled at runtime.

This should not be used unless absolutely necessary. DO NOT build your
keybinds or anything else around the legacy API. Please see
|autopairs-backwards-compat| for the full discussion.

------------------------------------------------------------------------------
                                                            *g:AutoPairsVersion*
|g:AutoPairsVersion|                                                         int

Defines the current version. There's 5 numbers, indicating:
Major, minor, patch, beta, alpha, in that order.

This is purely meant for script use, as well as cosmetic use if desired. This
also exists, in combination with * in |exists()|, to prevent major backwards
compat fuckups, such as the one caused by moving functions into the
`autopairs#` prefix.

------------------------------------------------------------------------------
                                                              *g:AutoPairsCRKey*
|g:AutoPairsCRKey|                                                       keybind

Default: '<CR>'

Defines what key to use as CR if |g:AutoPairsMapCR| is true.

This is added as a fallback compatibility option, as well as an option for
only expanding pairs on a different key. The compatibility bit is largely as a
hack for when plugins think <CR> is only and will only be mapped to their
plugin, and that no other plugins are gonna use it.

------------------------------------------------------------------------------
                                                      *g:AutoPairsJumpBlacklist*
|g:AutoPairsJumpBlacklist|                                                  list
This variable also exists in a buffer variant.~

Default: []

Defines a set of close keybinds that don't trigger jump. Note that this is
independent of flymode; set |g:AutoPairsNoJump| = 1 to disable normal pair
jumping entirely.

------------------------------------------------------------------------------
                                                        *g:AutoPairsFlyModeList*
|g:AutoPairsFlyModeList|                                                   regex
This variable also exists in a buffer variant.~

Default: '}\])'

Defines what close pairs trigger fly mode if |g:AutoPairsFlyMode| is enabled.
Used inside a |\v| |regex| group. ] MUST be escaped (`\]` instead of `]`), or
stuff breaks.

------------------------------------------------------------------------------
                                          *g:AutoPairsMultilineCloseDeleteSpace*
|g:AutoPairsMultilineCloseDeleteSpace|                                       int
This variable also exists in a buffer variant.~

Default: 1

Note that this only takes effect if |g:AutoPairsMultilineClose|. In theory.
I'm not sure what other cases this potentially is triggered, because the code
has extremely few comments from upstream (jiangmiao and Krasjet).

Defines whether or not to delete the space in the event of a multiline close.
From the readme, there's this example: >
    {
        | (press })
    }
<
>
    {
    }|
<

Turning this option off when |g:AutoPairsMultilineClose| is 1 makes the
outcome: >
    {

    }|
<

------------------------------------------------------------------------------
                                                  *g:AutoPairsMultibyteFastWrap*
|g:AutoPairsMultibyteFastWrap|                                               int
This variable also exists in a buffer variant.~

Default: 1

Whether or not to enable multibyte fast wrap. Note that this is currently
considered experimental even though it's enabled by default. If you experience
that it doesn't work, please open an issue.

When this is enabled, it enables wrapping multibyte pairs -- note that it only
does this for pairs registered in *g:AutoPairs* , as arbitrary selections
would be unpredictable.

If a multibyte pair or a normal pair isn't found, it'll fall back to standard
behavior and assume the next character is what you want to wrap.

------------------------------------------------------------------------------
                                                  *g:AutoPairsFiletypeBlacklist*
|g:AutoPairsFiletypeBlacklist|                                             array

Default: []

List containing filetypes in which autopairs is disabled by default. Note that
the keybinds and whatnot are loaded due to how the plugin is built up. This
may change in a future version. The plugin may be manually enabled in spite of
this blacklist. See |g:AutoPairsShortcutToggle|

------------------------------------------------------------------------------
                                                          *b:AutoPairsJumpRegex*
|b:AutoPairsJumpRegex|                                                     regex

Default: (undefined, generated on-demand as a regex group of buffer pairs)

Regex used with `search` when |g:AutoPairsShortcutJump| is used. This is
generated automatically per-buffer the first time the function is used, to
prevent unnecessary regeneration, or unnecessary generation if it's not used.

If this is defined when auto-pairs normally tries to generate it, it'll assume
the variable already exists, and use whatever is in it as the jump regex. This
can therefore be used to define a custom jump system (but only for the
explicit jumps), but it can also break it.

Also note that the regex is prefixed with a `\V` regardless of the source. If
you need to use this explicitly, be aware of that. You can prefix the variable
with `\v` to ignore the effects of `\V`, but you'll otherwise have to follow
the syntax rules for when `\V` is in effect.

See also: |\v|, |\V|

==============================================================================
6. Troubleshooting                                   *autopairs-troubleshooting*

This plugin remaps keys `([{'"}]) <BS>`

If auto pairs cannot work, use |:imap| to check if the map is corrected.

The correct map should be: >

    <C-R>=AutoPairsInsert("\(")<CR>

Or the plugin conflicts with some other plugins. Use command: >
    :call AutoPairsInit()
<
to remap the keys.

--- How to insert parens purely? ---

There are 3 ways:

    1. Use `Ctrl-V )` to insert paren without trigger the plugin.

    2. Use `Alt-P` to turn off the plugin.

    3. Use `DEL` or `<C-O>x` to delete the character insert by plugin.

------------------------------------------------------------------------------
6.1. Conflicting keybinds                                 *autopairs-conflicts*

European letters~
AutoPairs has a mapping that uses the alt key (meta) in such a way that it
conflicts with the letter Ã¥. This one specifically originates from Alt-E,
which is consumed by |g:AutoPairsShortcutFastWrap|.

While this is a known conflict, there could always be other. To see if there's
a conflict with a key on your keyboard, `verbose imap <insert letter>` and see
what it says. See: https://vi.stackexchange.com/q/20995/21251. You should be
able to backtrace the keybind from there, and using the options discussed in
|autopairs-conflicts|, remap it to something else.

From issues on the original autopairs repo, however, it's abundantly clear
that this isn't specific to scandinavian languages: a few of the meta keybinds
directly conflict with various letters for other european languages. Normally,
this wouldn't be a problem, but in insert mode mappings? They, to say the
least, introduces challenges.

The obvious option would be to remap them to something else. Personally, I
have no idea what I'd rather have some of these things mapped to. It's
definitely open for discussion to remap these to something more sane,
especially since mapping to meta in insert mode is, well, dumb, since
meta-<letter> has other meanings. I'll revisit this when I get some input on
the matter. Until then, if there's a conflict,  you'll need to track it down
(`verbose imap`) and fix it

Other plugins~
There's relatively little to do about conflicts with other plugins.

This plugin tries its best to make sure it doesn't override other mappings, by
"importing" other maps, but these may still occur. Auto-pairs' mappings are
done on a per-buffer basis, so it _should_ be compatible with other plugins,
but edge cases may still occur.

If you find yourself in a situation where you're unable to make sure enter does
what you want, you can always write a function and map <cr> to that. However,
thanks to plugins being weird, you may have to disable bits that remap <cr> for
this to work at all.

Pull requests/issues~
If you read any of this and you can tell me I'm wrong, and offer a solution or
a start, either as a pull request or as an issue, please do let me know. I'm
more than willing to hear alternative solutions to this problem that cause
less inconvenience for the users.

==============================================================================
7. Diagnose indent                                   *autopairs-diagnose-indent*
                                                     *autopairs-indent-problems*
If you've been using the plugin for a while, or if you by chance happen to
read this section before using it, you might've noticed that if you do this:
>
    func(|)   (press cr)
<
You're left with:
>
    func(

        )
<

... possibly with another indent level, or possibly something else you don't
like. You might even have come here wondering how you make it: >
    func(

    )
<

There's a ton of combinations or variations, and to make a long story
short, this is outside the plugin's hands. At the end of the day, Vim does the
actual formatting, and does so independently of the plugin. You might see where
this is going.

cino is essentially your friend here. Dealing with the problem listed above
can be done with `set cino+=m1`

There's no real solution to this aside reading the cino documentation.
(|indent|) Vim determines how to handle indentation. Any weird intentation
is, with very few exceptions, gonna be Vim's fault.

That being said, feel free to look around
[GitHub Discussions](https://github.com/LunarWatcher/auto-pairs/discussions)
for the plugin, and see if anyone else has asked whatever it is you have. If
you can't find anything, feel free to open a discussion to ask for help -
while it may not be the plugin's fault, that doesn't mean we're gonna leave
all the debugging and testing to you, especially when the cino documentation
is as huge as it is.

Note also that there's a whole lot of other ways to indent. Aside cino, some
languages have their own, additional variables for indentation. Some
languages, notably Python, also have plugins that add indent settings.
|indent| covers the vast majority of the built-in ones, and for the rest,
there's probably plugins

As far as I can tell though, cino applies to all the different files, though
some languages have additional configuration types. All I have left to say now
is to repeat: look at |indent|. If you can't find a cino setting to cover it,
or cino doesn't work for your language, look for language-specific options, or
possibly plugins to better handle indentation. If you're stuck, you can ask on
GitHub Discussions.

Alternatively, some languages can have plugins that deal with indentation
based on some language standard, or just adding it in general (depending on
how niche the language is). Here's a short and incomplete list of such
plugins:
* https://github.com/Vimjas/vim-python-pep8-indent

==============================================================================
8. Functions                                               *autopairs-functions*

Autopairs defines a lot of functions that you're probably never going to use.
There are, however, a couple that may have to be used in scripting contexts,
or remapping contexts.
Not using |autopairs#AutoPairsDefine()| will result in the standards being lost. If you
don't want to use the standards, go ahead and omit this function.
Additionally, if you want to add new types after loading, you need to use
|autopairs#AutoPairsMap()|

------------------------------------------------------------------------------
AutoPairsDefine()          *autopairs#AutoPairsDefine()* *autopairs-copy-defaults*
Arguments: (pairs[, pairs_to_remove])

    pairs                   Type: Map of key-value pairs
                            Defines what additional keys to include in the
                            map.

    pairs_to_remove         Type: list of keys
                            Lists keys to remove from the default
                            configuration. Optional; defaults to []

This function is used for defining additional keys. Example use: >
    autocmd VimEnter * let g:AutoPairs = autopairs#AutoPairsDefine({'<': '>'})
    autocmd FileType liquid let b:AutoPairs = autopairs#AutoPairsDefine({'{%': '%}'})
<

Note that in newer versions of the plugin, the autocmd is redundant, as core
parts of the plugin has been moved to an autoload file. As outlined in
[this](https://vi.stackexchange.com/a/14010/21251) answer on vi.SE, autoload
files are loaded when `autopair#` functions are called. This means using, for
an instance, `autopairs#AutoPairsDefine` loads the file and makes the function
valid.
                                               *autopairs#AutoPairsScriptInit()*
If you want to access something that doesn't have an associated function (such
as index-assigning autopairs), you can call `autopairs#AutoPairsScriptInit`,
which does absolutely nothing (the function is, as can be verified by the
reader, empty), aside forcing autopairs to load.

------------------------------------------------------------------------------
AutoPairsMap()                     *autopairs#AutoPairsMap()* *auto-pairs-map-key*
Arguments: (key)

    key                     Type: keybind
                            Defines a key to `inoremap` to auto-complete
                            pairs.

This function might end up being useless for you, but it's documented in case
it ends up being useful for someone.

The function maps a key to autocomplete another. The input argument is the
key to detect; if the pair is '(', ')', the key passed to the function should
be '('.

You don't need to call this manually, unless you're doing something that adds
additional pairs after the plugin is loaded. This shouldn't normally be a
problem, at least if you stick to |FileType|, but if you have some fancy code
relying on this ability, you'll have to use this function.
------------------------------------------------------------------------------
AutoPairsFastWrap()                              *autopairs#AutoPairsFastWrap()*
Arguments: ([movement])

Invoked when attempting a fast wrap. `movement` defines the fallback movement
(NOTE: behavior may be changed to general movement in the future), as in what
key is pressed to do a movement. By default, it's |e|.

Note that the existence of |g:AutoPairsShortcutFastWrap| means you won't need
to map a key to this function unless:
    1. You want a different movement
    2. You want a second mapping
    3. You're doing scripting involving the function

==============================================================================
9. Credits                                                   *autopairs-credits*

Being a fork (and open-source), this plugin does contain work from other
people.

If it wasn't obvious already, the plugin itself is based on
jiangmiao/auto-pairs. Jiangmiao's work laid the foundation for this plugin.

Additionally, it contains quite a bit of work from Krasjet, as their work on a
fork for personal use has been merged into this plugin.

Additionally, there's a number of contributors to jiangmiao's upstream repo,
and in the future possibly directly on this fork, who have contributed to the
plugin. The complete list is available on GitHub:

    https://github.com/LunarWatcher/auto-pairs/graphs/contributors

==============================================================================
10. Backwards compatibility                         *autopairs-backwards-compat*

Backwards compat is apparently tricker than initially expected. Following the
resolution of [issue 12](https://github.com/LunarWatcher/auto-pairs/issues/12)
in a semi-ugly way, it became apparent that backwards compatibility not being
maintained has consequences.

If you look at the changelog, you'll pretty quickly notice that the
3.0.0-alpha* releases come with a few major overhauls, including moving the
plugin to an autoload file. This also includes renaming all the functions to
autopairs#<old function name>, as well as renaming the main script file.

As for consequences, at least one plugin has been identified that relies on
autopairs function access. At this time, updating the remote plugins aren't
really an option, because use of this fork isn't wide-spread. Asking for
changes for a fork like that is likely to be rejected, and as such, this
plugin will temporarily introduce a backwards compat API. This literally means
adding functions with the old names (on an as needed basis) and exposing them
when |g:AutoPairsBackwardsCompat| is 1.

The legacy API is minimal and togglable because it SHOULD NOT be used; it only
exists to prevent other plugins from breaking in an either temporary or
permanent transition period. This plugin shouldn't break other plugins, which
is why the backwards compatible API exists. Keybinds are not considered
protected; if you rely on keybinds accessing autopairs API features, please
migrate them by adding `autopairs#` to the function name.

The migration should involve very little work; only the prefix (or whatever
it's called) has changed, and as such, the call only has to be changed. Again,
the backwards compatible API only exists to prevent breaking plugins for
people jumping from jiangmiao/auto-pairs to this fork, and should not be used
to add new keybinds, or build new plugins around it. Plugins built with this
one in mind should not use the backwards compat API intentionally; use the
new one.

To aid with backwards compat in the future, |g:AutoPairsVersion| has been
added to identify versions to give an easy way to detect API changes for
plugin compatibility. Unfortunately, it's introduced so late it's not really
useful for a few years.

vim:ft=help
